<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>æ·±æ·µçµæ‰‹ï¼šæ™‚ç©ºä¸»å®°</title>
    <style>
        body { background: #050505; color: #eee; font-family: 'Consolas', monospace; display: flex; flex-direction: column; align-items: center; margin: 0; overflow: hidden; }
        .game-layout { display: flex; gap: 15px; padding: 15px; width: 1450px; height: 98vh; box-sizing: border-box; }
        .sidebar { width: 230px; background: #151515; padding: 15px; border: 2px solid #333; border-radius: 8px; }
        .stat-line { font-size: 14px; line-height: 2.2; border-bottom: 1px solid #222; }
        .stat-val { float: right; font-weight: bold; }
        #game-area { position: relative; }
        canvas { background: #000; border: 4px solid #222; image-rendering: pixelated; }
        #boss-hp-bar { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 500px; height: 12px; background: #333; border: 2px solid #fff; display: none; z-index: 10; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(to right, #c0392b, #ff0000); transition: 0.2s; }
        .right-panel { width: 450px; display: flex; flex-direction: column; gap: 10px; }
        .spell-card { background: #1e272e; padding: 10px; border: 1px solid #3d3d3d; border-radius: 5px; margin-bottom: 5px; }
        .spell-key { background: #3498db; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold; margin-right: 5px; }
        .spell-key.fire { background: #e74c3c; }
        .log { height: 250px; background: #000; padding: 10px; font-size: 13px; border: 1px solid #333; overflow-y: auto; color: #aaa; border-radius: 8px; }
        .danger { color: #e74c3c; font-weight: bold; } .info { color: #3498db; } .magic { color: #9b59b6; } .boss { color: #f1c40f; }
    </style>
</head>
<body>

<div id="boss-hp-bar">
    <div id="boss-hp-fill"></div>
    <div id="boss-name" style="position:absolute; width:100%; text-align:center; top:-20px; font-size:12px; color:white;"></div>
</div>

<div class="game-layout">
    <div class="sidebar">
        <h3 style="color:#3498db; text-align:center;">ğŸ§™ æ™‚ç©ºå¥§è¡“å¸«</h3>
        <div class="stat-line">â¤ï¸ ç”Ÿå‘½ <span id="s-hp" class="stat-val danger">100/100</span></div>
        <div class="stat-line">ğŸ§ª èƒ½é‡ <span id="s-mp" class="stat-val info">25/25</span></div>
        <div class="stat-line">âš”ï¸ è¡“åŠ› <span id="s-atk" class="stat-val magic">20</span></div>
        <div class="stat-line">ğŸ’° é‡‘å¹£ <span id="s-gold" class="stat-val" style="color:#f1c40f">0</span></div>
        <div class="stat-line">ğŸŒ€ è¼ªè¿´ <span id="s-loop" class="stat-val">1</span></div>
        <div class="stat-line">ğŸ° å±¤æ•¸ <span id="s-floor" class="stat-val">1</span></div>
        <hr border="0" style="border-top:1px solid #333">
        <h4 style="color:#888;">æ™‚ç©ºæ³•è¡“:</h4>
        <div class="spell-card"><span class="spell-key fire">Q</span> ç«çƒè¡“ (3MP)<br><small>ç›´ç·šè²«ç©¿å‚·å®³</small></div>
        <div class="spell-card"><span class="spell-key">E</span> å†°çˆ†é™£ (5MP)<br><small>5x5 ç¯„åœå†°å‡å‚·å®³</small></div>
        <div class="spell-card"><span class="spell-key" style="background:#9b59b6">R</span> è¿”å›è¡“ (2MP)<br><small>å›åˆ° 5 æ­¥å‰ä½ç½®</small></div>
    </div>

    <div id="game-area"><canvas id="gameCanvas" width="750" height="600"></canvas></div>

    <div class="right-panel">
        <div class="log" id="log"><div id="log-inner"></div></div>
        <div style="background:#151515; border:2px solid #333; padding:15px; border-radius:8px; flex-grow:1;">
            <h4 style="margin-top:0; color:#f1c40f;">ğŸ‘¹ ç•¶å‰ä¸»å®°è³‡è¨Š</h4>
            <div id="boss-desc" style="font-size:13px; color:#999; line-height:1.6;">æ­£åœ¨æ¢ç´¢æ·±æ·µ...</div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE = 30, GW = 25, GH = 20;

let floor = 1, gold = 0, mpRegen = 0, loopCount = 1;
let player = { x: 5, y: 5, hp: 120, maxHp: 120, mp: 25, maxMp: 25, atk: 20 };
let dungeon = [], enemies = [], effects = [], moveHistory = [];

const BOSS_LIST = [
    { name: "åœ°ç„é ˜ä¸» - é˜¿åŠ é›·æ–¯", emoji: "ğŸ‘¹", desc: "æ“æœ‰å¼·å¤§çš„ç«ç„°è­·ç›¾èˆ‡å…¨å±åœ°ç«æ”»æ“Šã€‚" },
    { name: "è™›ç©ºæš—å½± - è²åˆ©äº", emoji: "ğŸ‘»", desc: "æœƒè£½é€ è™›æ“¬åˆ†èº«ï¼Œéš±è—åœ¨é»‘æš—ä¸­è¥²æ“Šã€‚" },
    { name: "è²ªå©ªä¹‹ç‹ - ç‘ªé–€", emoji: "ğŸ‘º", desc: "æœƒåœ¨åœ°é¢ä½ˆç½®å¤§é‡é‡‘å¹£ç‚¸å½ˆé™·é˜±ã€‚" },
    { name: "æ·±æ·µå·¨ç¸ - åˆ©ç¶­å¦", emoji: "ğŸ‰", desc: "å™´åæ¥µå¯’æ°£æ¯ï¼Œæœƒå‡çµä¸¦å·å–ä½ çš„èƒ½é‡ã€‚" }
];

function initLevel() {
    dungeon = Array(GH).fill().map(() => Array(GW).fill(1));
    enemies = []; effects = []; moveHistory = [];
    const isBossFloor = (floor % 5 === 0);
    
    if(isBossFloor) {
        for(let y=4; y<GH-4; y++) for(let x=4; x<GW-4; x++) dungeon[y][x] = 0;
        player.x = 12; player.y = 15;
        spawnBoss();
        document.getElementById('boss-hp-bar').style.display = 'block';
    } else {
        document.getElementById('boss-hp-bar').style.display = 'none';
        let cx = 12, cy = 10; player.x = cx; player.y = cy;
        for(let i=0; i<600; i++) {
            dungeon[cy][cx] = 0;
            let d = Math.floor(Math.random()*4);
            if(d===0 && cy>1) cy--; else if(d===1 && cy<GH-2) cy++;
            else if(d===2 && cx>1) cx--; else if(d===3 && cx<GW-2) cx++;
        }
        place(2, 1); 
        for(let i=0; i<4 + loopCount; i++) spawnEnemy();
    }
    updateUI();
}

function spawnEnemy() {
    let x, y;
    do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); }
    while(dungeon[y][x] !== 0 || (x===player.x && y===player.y));
    let scale = 1 + (loopCount - 1) * 0.5;
    enemies.push({ x, y, hp: (50+floor*5)*scale, maxHp: (50+floor*5)*scale, atk: (6+floor)*scale, isFrozen: 0, type: 'mob' });
}

function spawnBoss() {
    let bossIdx = (Math.floor(floor/5) - 1) % 4;
    let bData = BOSS_LIST[bossIdx];
    let scale = 1 + (loopCount - 1) * 0.8;
    enemies.push({ 
        x: 12, y: 7, hp: (1200 + floor*100) * scale, maxHp: (1200 + floor*100) * scale, 
        atk: (22 + floor) * scale, type: 'boss', bossType: bossIdx, timer: 0, shield: 0, name: bData.name, emoji: bData.emoji
    });
    document.getElementById('boss-name').innerText = bData.name;
    document.getElementById('boss-desc').innerText = bData.desc;
    addLog("âš ï¸ è­¦å‘Šï¼šå¤§ä¸»å®° " + bData.name + " å·²ç¾èº«ï¼", "danger");
}

function place(val, n) {
    for(let i=0; i<n; i++) {
        let x, y;
        do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); } while(dungeon[y][x] !== 0);
        dungeon[y][x] = val;
    }
}

function tryMove(dx, dy) {
    let nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= GW || ny < 0 || ny >= GH || dungeon[ny][nx] === 1) return;

    let target = enemies.find(e => e.x === nx && e.y === ny);
    if (target) {
        dealDamage(target, player.atk);
    } else {
        moveHistory.push({x: player.x, y: player.y});
        if (moveHistory.length > 10) moveHistory.shift();
        player.x = nx; player.y = ny;
        if (dungeon[ny][nx] === 2) { 
            floor++; 
            if(floor > 20) { loopCount++; floor = 1; }
            initLevel(); return; 
        }
    }
    endTurn();
}

function castQ() {
    if(player.mp < 3) return;
    player.mp -= 3;
    addLog("ğŸ”¥ å¥§è¡“ç«çƒï¼", "magic");
    [[0,-1],[0,1],[-1,0],[1,0]].forEach(d => {
        for(let i=1; i<=5; i++) {
            let tx = player.x + d[0]*i, ty = player.y + d[1]*i;
            effects.push({x: tx, y: ty, life: 6, type: 'fire'});
            let target = enemies.find(e => e.x === tx && e.y === ty);
            if(target) { dealDamage(target, player.atk * 3); break; }
        }
    });
    endTurn();
}

function castE() {
    if(player.mp < 5) return;
    player.mp -= 5;
    addLog("â„ï¸ å¥§è¡“å†°çˆ†é™£ï¼", "info");
    for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
            let tx = player.x + dx, ty = player.y + dy;
            if (tx >= 0 && tx < GW && ty >= 0 && ty < GH) {
                effects.push({x: tx, y: ty, life: 10, type: 'ice'});
                let target = enemies.find(e => e.x === tx && e.y === ty);
                if (target) { target.isFrozen = 4; dealDamage(target, player.atk * 2); }
            }
        }
    }
    endTurn();
}

function castR() {
    if(player.mp < 2) return;
    if(moveHistory.length < 1) { addLog("ğŸš« ç„¡æ³•æº¯æºï¼", "info"); return; }
    player.mp -= 2;
    let targetIdx = Math.max(0, moveHistory.length - 5);
    let lastPos = moveHistory[targetIdx];
    effects.push({x: player.x, y: player.y, life: 8, type: 'ice'});
    player.x = lastPos.x; player.y = lastPos.y;
    moveHistory = moveHistory.slice(0, targetIdx);
    addLog("ğŸŒ€ æ™‚ç©ºè¿”å›ï¼", "magic");
    effects.push({x: player.x, y: player.y, life: 8, type: 'ice'});
    endTurn();
}

function dealDamage(en, dmg) {
    if(en.shield > 0) { en.shield -= dmg; return; }
    en.hp -= dmg;
    if(en.hp <= 0) {
        if(en.type === 'boss') { addLog("ğŸ† æ“Šæ•—ä¸»å®°ï¼é€šå¾€æ·±è™•...", "boss"); dungeon[en.y][en.x] = 2; player.atk += 5; }
        gold += en.type === 'boss' ? 300 : 25;
        enemies = enemies.filter(e => e !== en);
    }
}

function endTurn() {
    enemies.forEach(en => {
        if(en.isFrozen > 0) { en.isFrozen--; return; }
        if(en.type === 'boss') bossAI(en);
        else {
            let dx = Math.sign(player.x - en.x), dy = Math.sign(player.y - en.y);
            if(Math.abs(player.x-en.x)+Math.abs(player.y-en.y) === 1) player.hp -= en.atk;
            else if(dungeon[en.y+dy][en.x+dx] === 0) { en.x += dx; en.y += dy; }
        }
    });
    effects.forEach(eff => { if(eff.type === 'trap' && eff.x === player.x && eff.y === player.y) { player.hp -= 30; eff.life = 0; addLog("ğŸ’¥ è¸©ä¸­é™·é˜±ï¼", "danger"); } });
    mpRegen++; if(mpRegen >= 2) { player.mp = Math.min(player.maxMp, player.mp+1); mpRegen=0; }
    if(player.hp <= 0) { alert("æ¶ˆé€æ–¼æ™‚ç©ºä¸­..."); location.reload(); }
    updateUI();
}

function bossAI(b) {
    b.timer++;
    if(b.bossType === 0) { // é˜¿åŠ é›·æ–¯
        if(b.timer % 4 === 0) b.shield = 250;
        if(b.timer % 6 === 0) { player.hp -= 20; addLog("ğŸ”¥ é˜¿åŠ é›·æ–¯ é‡‹æ”¾åœ°ç«ï¼", "danger"); }
    } else if(b.bossType === 1) { // è²åˆ©äº
        if(b.timer % 5 === 0) {
            for(let i=0; i<2; i++) {
                let x = Math.floor(Math.random()*GW), y = Math.floor(Math.random()*GH);
                if(dungeon[y][x]===0) enemies.push({x, y, hp:1, maxHp:1, atk:10, type:'mob', emoji:"ğŸ‘¤"});
            }
        }
    } else if(b.bossType === 2) { // ç‘ªé–€
        if(b.timer % 3 === 0) effects.push({ x: player.x, y: player.y, life: 10, type: 'trap' });
    } else if(b.bossType === 3) { // åˆ©ç¶­å¦
        if(b.timer % 2 === 0) { player.mp = Math.max(0, player.mp - 2); addLog("â„ï¸ åˆ©ç¶­å¦ åå™¬äº†ä½ çš„èƒ½é‡ï¼", "info"); }
    }
    let dx = Math.sign(player.x - b.x), dy = Math.sign(player.y - b.y);
    if(Math.abs(player.x-b.x)+Math.abs(player.y-b.y) === 1) player.hp -= b.atk;
    else { b.x += dx; b.y += dy; }
}

function draw() {
    ctx.clearRect(0,0,750,600); ctx.textAlign = "center"; ctx.textBaseline = "middle";
    for(let y=0; y<GH; y++) {
        for(let x=0; x<GW; x++) {
            ctx.fillStyle = dungeon[y][x] === 1 ? "#222" : "#080808";
            ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
            if(dungeon[y][x] === 2) ctx.fillText("ğŸªœ", x*TILE+TILE/2, y*TILE+TILE/2);
        }
    }
    effects.forEach((eff, i) => {
        ctx.globalAlpha = eff.life / 12;
        ctx.fillStyle = eff.type === 'fire' ? "#ff5e00" : (eff.type === 'ice' ? "#00d4ff" : "#f1c40f");
        ctx.fillRect(eff.x*TILE, eff.y*TILE, TILE, TILE);
        eff.life--; if(eff.life <= 0) effects.splice(i, 1);
    });
    ctx.globalAlpha = 1;
    enemies.forEach(en => {
        ctx.font = en.type === 'boss' ? "35px Arial" : "22px Arial";
        ctx.fillStyle = en.isFrozen > 0 ? "#00d4ff" : (en.type === 'boss' ? "#ff0000" : "#eee");
        ctx.fillText(en.emoji || "ğŸ‘º", en.x*TILE+TILE/2, en.y*TILE+TILE/2);
        const bw = TILE*0.8; ctx.fillStyle = "#f00"; ctx.fillRect(en.x*TILE+(TILE-bw)/2, en.y*TILE+TILE-4, bw*(en.hp/en.maxHp), 3);
    });
    ctx.font = "24px Arial"; ctx.fillText("ğŸ§™", player.x*TILE+TILE/2, player.y*TILE+TILE/2);
}

function updateUI() {
    document.getElementById('s-hp').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
    document.getElementById('s-mp').innerText = `${player.mp}/${player.maxMp}`;
    document.getElementById('s-gold').innerText = gold;
    document.getElementById('s-floor').innerText = floor;
    document.getElementById('s-loop').innerText = loopCount;
    let b = enemies.find(e => e.type === 'boss');
    if(b) document.getElementById('boss-hp-fill').style.width = (b.hp / b.maxHp * 100) + "%";
}

function addLog(m, cl="") {
    let d = document.createElement('div'); d.className = cl; d.innerText = "> " + m;
    const log = document.getElementById('log-inner'); log.prepend(d);
}

window.addEventListener('keydown', e => {
    const k = e.key.toUpperCase();
    if(k==='W' || e.key==='ArrowUp') tryMove(0,-1);
    else if(k==='S' || e.key==='ArrowDown') tryMove(0,1);
    else if(k==='A' || e.key==='ArrowLeft') tryMove(-1,0);
    else if(k==='D' || e.key==='ArrowRight') tryMove(1,0);
    else if(k==='Q') castQ(); else if(k==='E') castE(); else if(k==='R') castR();
});

initLevel();
setInterval(draw, 50);
</script>
</body>
</html>
