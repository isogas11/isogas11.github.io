<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>æ·±æ·µçµæ‰‹ï¼šå¥§è¡“ç¶­åº¦ v7.0</title>
    <style>
        :root { --bg: #030303; --ui: #151515; --border: #3498db; --accent: #f1c40f; }
        body { background: var(--bg); color: #eee; font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; display: flex; align-items: center; justify-content: center; margin: 0; height: 100vh; overflow: hidden; }
        .game-layout { display: flex; gap: 20px; width: 98vw; height: 95vh; }
        .sidebar { width: 320px; background: var(--ui); padding: 15px; border: 2px solid var(--border); border-radius: 12px; display: flex; flex-direction: column; gap: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .stat-line { font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .stat-val { float: right; color: var(--accent); font-weight: bold; }
        #game-viewport { flex-grow: 1; position: relative; border-radius: 10px; overflow: hidden; border: 2px solid #333; background: #000; }
        canvas { display: block; }
        .modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 420px; background: #1a1a1a; border: 3px solid var(--accent); padding: 20px; display: none; z-index: 1000; border-radius: 15px; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        .btn-opt { background: #252525; border: 1px solid #444; padding: 12px; color: #fff; cursor: pointer; display: flex; justify-content: space-between; border-radius: 8px; margin-bottom: 8px; }
        .log { flex-grow: 1; background: #000; padding: 10px; font-size: 12px; overflow-y: auto; color: #999; border-radius: 8px; border: 1px solid #222; }
    </style>
</head>
<body>

<div id="building-ui" class="modal">
    <h2 id="modal-title" style="text-align:center; color:var(--accent);">ğŸ›ï¸ å»ºç¯‰</h2>
    <div id="modal-content"></div>
    <button onclick="closeModal()" style="width:100%; margin-top:10px; padding:10px; cursor:pointer; background:#444; color:white; border:none; border-radius:5px;">é›¢é–‹</button>
</div>

<div class="game-layout">
    <div class="sidebar">
        <h3 style="text-align:center; margin:0; color:#2ecc71">Lv.<span id="s-lv">1</span> å¥§è¡“å¤§å¸«</h3>
        <div class="stat-line">â¤ï¸ ç”Ÿå‘½ <span id="s-hp" class="stat-val">100/100</span></div>
        <div class="stat-line">ğŸ§ª é­”åŠ› <span id="s-mp" class="stat-val">30/30</span></div>
        <div class="stat-line">âš”ï¸ è¿‘æˆ° <span id="s-atk" class="stat-val">10</span></div>
        <div class="stat-line">ğŸ”® è¡“åŠ› <span id="s-mgk" class="stat-val">10</span></div>
        <div class="stat-line">ğŸ’° é‡‘å¹£ <span id="s-gold" class="stat-val">100</span></div>
        <div class="stat-line">ğŸ° å±¤æ•¸ <span id="s-floor" class="stat-val">1</span></div>
        <div class="log" id="log"></div>
        <div id="passive-ui" style="font-size:11px; color:#a29bfe;"></div>
        <div id="spell-ui"></div>
    </div>
    <div id="game-viewport">
        <canvas id="gameCanvas"></canvas>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TILE = 40; // æ ¼å­å¤§å°
const GW = 80, GH = 60; // åœ°åœ–æ“´å¤§ 4 å€ (å¾ 40x30 è®Š 80x60)
let floor = 1, gold = 100, lv = 1, exp = 0, nextExp = 100;
let dungeon = [], enemies = [], effects = [];
let passives = [], playerSpells = ['Q'];
let currentBuilding = null;

let player = { x: 40, y: 30, maxHp: 100, hp: 100, maxMp: 30, mp: 30, atk: 10, mgk: 10, def: 0, cd: {} };

function initLevel() {
    dungeon = Array(GH).fill().map(() => Array(GW).fill(1));
    enemies = []; effects = [];
    
    // ç”Ÿæˆå¤§åœ°åœ–
    let cx = Math.floor(GW/2), cy = Math.floor(GH/2);
    player.x = cx; player.y = cy;
    for(let i=0; i<3500; i++) {
        dungeon[cy][cx] = 0;
        let d = Math.floor(Math.random()*4);
        if(d===0 && cy>2) cy--; else if(d===1 && cy<GH-3) cy++;
        else if(d===2 && cx>2) cx--; else if(d===3 && cx<GW-3) cx++;
    }

    // æ€ªç‰©æ•¸é‡é‚è¼¯
    let modFloor = floor % 10;
    if(modFloor === 0) {
        spawnEnemy(true); // é¦–é ˜å±¤
    } else {
        let count = 3 + modFloor + 1; // 1æ¨“=5éš», 2æ¨“=6éš»... 9æ¨“=13éš»
        for(let i=0; i<count; i++) spawnEnemy(false);
    }

    const bTypes = ["éµåŒ é‹ª", "é­”æ³•å•†åº—", "é“å…·åº—", "ç¥­å£‡", "è¨“ç·´å ´"];
    currentBuilding = { type: bTypes[Math.floor(Math.random()*bTypes.length)] };
    currentBuilding.items = generateShop(currentBuilding.type);
    
    placeSpec(2); placeSpec(3); 
    resizeCanvas();
    updateUI();
}

function placeSpec(v) {
    let x, y;
    do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); } 
    while (dungeon[y][x] !== 0 || Math.abs(x-player.x)+Math.abs(y-player.y) < 10);
    dungeon[y][x] = v;
}

function spawnEnemy(isBoss) {
    let x, y;
    do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); } while(dungeon[y][x] !== 0);
    let power = Math.floor(floor/5) * 50;
    enemies.push({
        x, y, isBoss,
        hp: (60 + power) * (isBoss ? 20 : 1), maxHp: (60 + power) * (isBoss ? 20 : 1),
        atk: (8 + Math.floor(power/10)) * (isBoss ? 2.5 : 1),
        emoji: isBoss ? "ğŸ‘‘" : ["ğŸ‘º", "ğŸ’€", "ğŸ‘»", "ğŸ¦‡"][Math.floor(Math.random()*4)],
        wounded: false
    });
}

function generateShop(type) {
    let list = [];
    if(type === "éµåŒ é‹ª") {
        list.push({ n: "âš”ï¸ å¼·åŒ– (è¿‘æˆ°+4)", p: 50, inf: true, f: () => player.atk+=4 });
        list.push({ n: "ğŸ›¡ï¸ åŠ å›º (é˜²ç¦¦+2)", p: 60, inf: true, f: () => player.def+=2 });
        list.push({ n: "ğŸ”® é™„é­” (è¡“åŠ›+5)", p: 50, inf: true, f: () => player.mgk+=5 });
    } else if(type === "é­”æ³•å•†åº—") {
        const spells = { 'E':150, 'F':250, 'V':120, 'X':450 };
        Object.keys(spells).forEach(k => {
            if(!playerSpells.includes(k)) list.push({ n: `ğŸ“œ å·è»¸ ${k}`, p: spells[k], id: k, f: () => playerSpells.push(k) });
        });
    } else if(type === "é“å…·åº—") {
        list.push({ n: "ğŸ§ª å¤§ç´…æ°´", p: 50, inf: true, f: () => player.hp=player.maxHp });
        list.push({ n: "âš¡ èƒ½é‡åŠ‘", p: 40, inf: true, f: () => player.mp=Math.min(player.maxMp, player.mp+25) });
    } else if(type === "è¨“ç·´å ´") {
        ["å¸è¡€", "å†¥æƒ³", "èŠæ£˜", "æ³•åŠ›è­·ç›¾"].filter(p=>!passives.includes(p)).forEach(p => {
            list.push({ n: `ğŸ§  è¦ºé†’ ${p}`, p: 200, id: p, f: () => passives.push(p) });
        });
    }
    return list;
}

function resizeCanvas() {
    canvas.width = document.getElementById('game-viewport').clientWidth;
    canvas.height = document.getElementById('game-viewport').clientHeight;
}

function draw() {
    if(!canvas.width) return;
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);

    // æ”å½±æ©Ÿé–å®š
    let camX = player.x * TILE - canvas.width / 2 + TILE/2;
    let camY = player.y * TILE - canvas.height / 2 + TILE/2;

    for(let y=0; y<GH; y++) {
        for(let x=0; x<GW; x++) {
            let dx = x * TILE - camX, dy = y * TILE - camY;
            if(dx < -TILE || dx > canvas.width || dy < -TILE || dy > canvas.height) continue;

            if(dungeon[y][x] === 1) {
                ctx.fillStyle = (x+y)%2===0 ? "#050505" : "#080808"; // ç„¡ç¶²æ ¼è¨­è¨ˆ
            } else {
                ctx.fillStyle = "#010101";
            }
            ctx.fillRect(dx, dy, TILE, TILE);

            ctx.font = `${TILE * 0.7}px Arial`;
            if(dungeon[y][x] === 2) ctx.fillText("ğŸªœ", dx + TILE*0.15, dy + TILE*0.75);
            if(dungeon[y][x] === 3) {
                const icons = {"éµåŒ é‹ª":"âš’ï¸","é­”æ³•å•†åº—":"ğŸ”®","é“å…·åº—":"ğŸ±","ç¥­å£‡":"â›©ï¸","è¨“ç·´å ´":"ğŸ‹ï¸"};
                ctx.fillText(icons[currentBuilding.type], dx + TILE*0.15, dy + TILE*0.75);
            }
        }
    }

    // ç¹ªè£½å–®ä½ (ç²¾ç¢ºæ§åˆ¶æ¯”ä¾‹ 0.9 å€ï¼Œä¸æº¢å‡º)
    const drawUnit = (emoji, x, y, isBoss) => {
        let dx = x * TILE - camX, dy = y * TILE - camY;
        ctx.font = `${TILE * 0.9}px Arial`;
        if(isBoss) { ctx.shadowBlur = 10; ctx.shadowColor = "red"; }
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(emoji, dx + TILE/2, dy + TILE/2);
        ctx.shadowBlur = 0; ctx.textAlign = "start"; ctx.textBaseline = "alphabetic";
    };

    enemies.forEach(en => {
        drawUnit(en.emoji, en.x, en.y, en.isBoss);
        if(en.wounded) {
            let dx = en.x * TILE - camX, dy = en.y * TILE - camY;
            ctx.fillStyle = "#333"; ctx.fillRect(dx + TILE*0.1, dy, TILE*0.8, 4);
            ctx.fillStyle = "#e74c3c"; ctx.fillRect(dx + TILE*0.1, dy, TILE*0.8*(en.hp/en.maxHp), 4);
        }
    });

    drawUnit("ğŸ§™â€â™‚ï¸", player.x, player.y, false);

    effects.forEach((eff, i) => {
        ctx.globalAlpha = eff.l/10; ctx.fillStyle = "#f1c40f";
        ctx.fillRect(eff.x * TILE - camX, eff.y * TILE - camY, TILE, TILE);
        eff.l--; if(eff.l<=0) effects.splice(i,1);
    });
    ctx.globalAlpha = 1;
}

function dealDamage(t, base, key) {
    let sc = key ? {Q:1.5, E:0.8, F:0.4, X:2.5}[key] : 1;
    let dmg = Math.floor((key ? player.mgk : player.atk) * sc);
    t.hp -= dmg; t.wounded = true;
    addLog(`âš”ï¸ é€ æˆ ${dmg} å‚·å®³`);
    if(t.hp <= 0) {
        gold += (t.isBoss ? 1000 : 40); gainExp(t.isBoss ? 1000 : 70);
        enemies = enemies.filter(e => e !== t);
    }
}

function endTurn() {
    Object.keys(player.cd).forEach(k => { if(player.cd[k]>0) player.cd[k]--; });
    enemies.forEach(en => {
        let dist = Math.abs(player.x-en.x) + Math.abs(player.y-en.y);
        if(dist === 1) {
            let d = Math.max(1, en.atk - player.def);
            player.hp -= d; addLog(`ğŸ’¥ å—åˆ° ${d} å‚·å®³`, "red");
        } else if(dist < 15) {
            let dx = Math.sign(player.x-en.x), dy = Math.sign(player.y-en.y);
            if(dungeon[en.y+dy][en.x+dx]===0 && !enemies.some(e=>e.x===en.x+dx && e.y===en.y+dy)) {
                en.x += dx; en.y += dy;
            }
        }
    });
    if(player.hp <= 0) { alert("æˆ°æ•—ï¼"); location.reload(); }
    updateUI();
}

function updateUI() {
    document.getElementById('s-hp').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
    document.getElementById('s-mp').innerText = `${Math.floor(player.mp)}/${player.maxMp}`;
    document.getElementById('s-atk').innerText = player.atk;
    document.getElementById('s-mgk').innerText = player.mgk;
    document.getElementById('s-gold').innerText = gold;
    document.getElementById('s-floor').innerText = floor;
    document.getElementById('s-lv').innerText = lv;
}

function gainExp(a) {
    exp += a; if(exp >= nextExp) { 
        lv++; exp -= nextExp; nextExp = Math.floor(nextExp * 1.6); 
        player.maxHp += 30; player.hp = player.maxHp; 
    }
}

function addLog(m, c) {
    let d = document.createElement('div'); if(c==="red") d.style.color="#ff4757";
    d.innerText = "> " + m; let l = document.getElementById('log'); l.prepend(d);
}

function openModal() {
    const m = document.getElementById('building-ui');
    const c = document.getElementById('modal-content');
    document.getElementById('modal-title').innerText = "ğŸ›ï¸ " + currentBuilding.type;
    m.style.display = 'block';
    c.innerHTML = "";
    currentBuilding.items.forEach((it, idx) => {
        let div = document.createElement('div'); div.className = "btn-opt";
        div.innerHTML = `<span>${it.n}</span><span style="color:var(--accent)">ğŸ’°${it.p}</span>`;
        div.onclick = () => {
            if(gold >= it.p) { gold -= it.p; it.f(); if(!it.inf) currentBuilding.items.splice(idx,1); updateUI(); openModal(); }
        };
        c.appendChild(div);
    });
}

function closeModal() { document.getElementById('building-ui').style.display = 'none'; }

window.addEventListener('keydown', e => {
    if(document.getElementById('building-ui').style.display === 'block') return;
    let k = e.key.toUpperCase();
    let dx = 0, dy = 0;
    if(k==='W') dy = -1; if(k==='S') dy = 1; if(k==='A') dx = -1; if(k==='D') dx = 1;
    if(dx!==0 || dy!==0) {
        let nx = player.x + dx, ny = player.y + dy;
        if(nx>=0 && nx<GW && ny>=0 && ny<GH && dungeon[ny][nx]!==1) {
            let target = enemies.find(e=>e.x===nx && e.y===ny);
            if(target) dealDamage(target, player.atk, null);
            else {
                player.x = nx; player.y = ny;
                if(dungeon[ny][nx]===2) { floor++; initLevel(); return; }
                if(dungeon[ny][nx]===3) openModal();
            }
            endTurn();
        }
    }
});

window.addEventListener('resize', resizeCanvas);
initLevel();
setInterval(draw, 30);
</script>
</body>
</html>
