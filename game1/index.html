<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>æ·±æ·µçµæ‰‹ï¼šå¥§è¡“ç¶­åº¦ v5.9</title>
    <style>
        :root { --bg: #050505; --ui: #1a1a1a; --border: #3498db; --accent: #f1c40f; }
        body { background: var(--bg); color: #eee; font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; overflow: hidden; }
        .game-layout { display: flex; gap: 15px; padding: 15px; width: 1450px; height: 98vh; box-sizing: border-box; }
        .sidebar { width: 340px; background: var(--ui); padding: 15px; border: 2px solid var(--border); border-radius: 12px; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; }
        .stat-line { font-size: 14px; line-height: 1.8; border-bottom: 1px solid #333; }
        .stat-val { float: right; font-weight: bold; color: #fff; }
        #game-area { position: relative; border-radius: 10px; overflow: hidden; border: 2px solid #333; background: #000; }
        canvas { display: block; }

        .modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 480px; background: #151515; border: 3px solid var(--accent); padding: 20px; display: none; z-index: 1000; border-radius: 15px; box-shadow: 0 0 50px rgba(0,0,0,0.9); }
        .btn-list { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; }
        .btn-opt { background: #222; border: 1px solid #444; padding: 12px; color: #fff; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-radius: 5px; }
        .btn-opt:hover { background: #333; border-color: var(--accent); }

        .log { flex-grow: 1; background: #000; padding: 10px; font-size: 12px; border: 1px solid #333; overflow-y: auto; color: #aaa; border-radius: 8px; }
        .passive-tag { background: #8e44ad; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 5px; margin-bottom: 5px; display: inline-block; color: white; }
    </style>
</head>
<body>

<div id="building-ui" class="modal">
    <h2 id="modal-title" style="text-align:center; color:var(--accent); margin-top:0;"></h2>
    <div id="modal-content" class="btn-list"></div>
    <button onclick="closeModal()" style="width:100%; margin-top:15px; padding:10px; cursor:pointer; background:#444; color:white; border:none; border-radius:5px;">é›¢é–‹</button>
</div>

<div class="game-layout">
    <div class="sidebar">
        <h3 style="text-align:center; margin:0; color:#2ecc71">Lv.<span id="s-lv">1</span> å¥§è¡“å¤§å¸«</h3>
        <div style="height:6px; background:#333; border-radius:3px;"><div id="exp-bar" style="height:100%; background:#2ecc71; width:0%"></div></div>
        
        <div class="stat-line">â¤ï¸ ç”Ÿå‘½ <span id="s-hp" class="stat-val">100/100</span></div>
        <div class="stat-line">ğŸ§ª é­”åŠ› <span id="s-mp" class="stat-val">30/30</span></div>
        <div class="stat-line">âš”ï¸ è¿‘æˆ°åŠ›é‡ <span id="s-atk" class="stat-val">10</span></div>
        <div class="stat-line">ğŸ”® é­”æ³•è¡“åŠ› <span id="s-mgk" class="stat-val">10</span></div>
        <div class="stat-line">ğŸ›¡ï¸ é˜²ç¦¦åŠ› <span id="s-def" class="stat-val">0</span></div>
        <div class="stat-line">ğŸ’° æŒæœ‰é‡‘å¹£ <span id="s-gold" class="stat-val" style="color:var(--accent)">100</span></div>
        <div class="stat-line">ğŸ° ç•¶å‰å±¤æ•¸ <span id="s-floor" class="stat-val">1</span></div>

        <div style="font-weight:bold; margin-top:10px; color:var(--border)">ğŸ§  è¢«å‹•æ•ˆæœ:</div>
        <div id="passive-ui"></div>

        <div style="font-weight:bold; margin-top:10px; color:var(--border)">ğŸ“œ æŠ€èƒ½æ›¸ (Q/E/F/V/X):</div>
        <div id="spell-ui"></div>
        
        <div class="log" id="log"></div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas" width="750" height="600"></canvas>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE = 30, GW = 25, GH = 20;

let floor = 1, gold = 100, lv = 1, exp = 0, nextExp = 100;
let dungeon = [], enemies = [], effects = [];
let passives = [], playerSpells = ['Q'];
let currentBuilding = null;

const PASSIVE_DATA = {
    "å¸è¡€": { desc: "è¿‘æˆ°é€ æˆå‚·å®³å›3è¡€", effect: (d) => 3 },
    "å†¥æƒ³": { desc: "æ¯å›åˆè‡ªå‹•å›å¾©1é­”åŠ›", effect: (d) => 1 },
    "èŠæ£˜": { desc: "å—å‚·æ™‚åå½ˆ50%å‚·å®³", effect: (d) => d * 0.5 },
    "æ³•åŠ›è­·ç›¾": { desc: "æ©Ÿç‡æŠµæ“‹30%å—åˆ°çš„å‚·å®³", effect: (d) => 0.7 }
};

const MONSTER_TYPES = [
    { name: "åœ°ç„çœ¼", shape: "square", color: "#e74c3c" },
    { name: "è…è•æ¶²", shape: "circle", color: "#2ecc71" },
    { name: "å½±é­”å…µ", shape: "diamond", color: "#9b59b6" }
];

const SPELLS = {
    'Q': { n: 'ç«çƒè¡“', mp: 2, cd: 2, sc: 1.5, d: 'ç›´ç·šå™´ç™¼', p: 0 },
    'E': { n: 'å†°çˆ†è¡“', mp: 5, cd: 5, sc: 0.8, d: 'å‘¨åœçˆ†ç‚¸', p: 150 },
    'F': { n: 'è¬åŠè¨£', mp: 8, cd: 10, sc: 0.4, d: 'å…¨å±éš¨æ©Ÿ', p: 250 },
    'V': { n: 'æ²»ç™’è¡“', mp: 4, cd: 12, sc: 0, d: 'å›å¾©30HP', p: 120 },
    'X': { n: 'æ¯€æ»…æ–°æ˜Ÿ', mp: 15, cd: 20, sc: 2.5, d: 'æ¸…ç†æˆ°å ´', p: 400 }
};

let player = { x: 5, y: 5, maxHp: 100, hp: 100, maxMp: 30, mp: 30, atk: 10, mgk: 10, def: 0, cd: {} };

function initLevel() {
    dungeon = Array(GH).fill().map(() => Array(GW).fill(1));
    enemies = []; effects = [];
    let cx = 12, cy = 10; player.x = cx; player.y = cy;
    for(let i=0; i<650; i++) {
        dungeon[cy][cx] = 0;
        let d = Math.floor(Math.random()*4);
        if(d===0 && cy>1) cy--; else if(d===1 && cy<GH-2) cy++;
        else if(d===2 && cx>1) cx--; else if(d===3 && cx<GW-2) cx++;
    }

    const types = ["éµåŒ é‹ª", "é­”æ³•å•†åº—", "é“å…·åº—", "ç¥­å£‡", "è¨“ç·´å ´"];
    let bType = types[Math.floor(Math.random()*types.length)];
    currentBuilding = { type: bType, items: generateShop(bType) };
    
    placeSpec(2); placeSpec(3); 
    
    let floorPower = Math.floor(floor/10) * 35;
    let count = 4 + (floor % 10);
    for(let i=0; i<count; i++) spawnEnemy(false, floorPower);
    if(Math.random() < 0.2) spawnEnemy(true, floorPower);

    updateUI();
}

function placeSpec(v) {
    let x, y;
    do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); } 
    while (dungeon[y][x] !== 0 || Math.abs(x-player.x)+Math.abs(y-player.y) < 5);
    dungeon[y][x] = v;
    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
        let ny = y+i, nx = x+j;
        if(ny>0 && ny<GH-1 && nx>0 && nx<GW-1) if(dungeon[ny][nx]===1) dungeon[ny][nx]=0;
    }
}

function spawnEnemy(isElite, power) {
    let x, y;
    do { x = Math.floor(Math.random()*GW); y = Math.floor(Math.random()*GH); } while(dungeon[y][x] !== 0);
    const mBase = MONSTER_TYPES[Math.floor(Math.random()*MONSTER_TYPES.length)];
    enemies.push({
        x, y, isElite,
        hp: (40 + power) * (isElite?5:1), maxHp: (40 + power) * (isElite?5:1),
        atk: (6 + Math.floor(power/8)) * (isElite?2:1),
        name: (isElite ? "ç˜‹ç‹‚çš„" : "") + mBase.name,
        shape: mBase.shape, color: mBase.color, lastHit: 0
    });
}

function generateShop(type) {
    let list = [];
    if(type === "éµåŒ é‹ª") {
        list.push({ n: "âš”ï¸ å¼·åŒ–é‹’èŠ’ (è¿‘æˆ°+4)", p: 50, inf: true, f: () => player.atk += 4 });
        list.push({ n: "ğŸ›¡ï¸ é›é€ è­·ç”² (é˜²ç¦¦+2)", p: 60, inf: true, f: () => player.def += 2 });
        list.push({ n: "ğŸ’ ç£¨è£½æ­¦å™¨ (è¡“åŠ›+4)", p: 50, inf: true, f: () => player.mgk += 4 });
    } else if(type === "é­”æ³•å•†åº—") {
        Object.keys(SPELLS).forEach(k => {
            if(!playerSpells.includes(k)) list.push({ n: `ğŸ“œ ${SPELLS[k].n}`, p: SPELLS[k].p, id: k, inf: false, f: () => playerSpells.push(k) });
        });
    } else if(type === "é“å…·åº—") {
        list.push({ n: "ğŸ§ª æ²»ç™’è—¥æ°´ (HPå…¨æ»¿)", p: 50, inf: true, f: () => player.hp = player.maxHp });
        list.push({ n: "âš¡ é­”åŠ›è—¥æ°´ (MP+20)", p: 30, inf: true, f: () => player.mp = Math.min(player.maxMp, player.mp+20) });
    } else if(type === "è¨“ç·´å ´") {
        Object.keys(PASSIVE_DATA).filter(p => !passives.includes(p)).forEach(p => {
            list.push({ n: `ğŸ§  ${p}`, p: 180, d: PASSIVE_DATA[p].desc, id: p, inf: false, f: () => passives.push(p) });
        });
    }
    return list;
}

function useAltar() {
    if(confirm("ç»ç¥­50%ç•¶å‰ç‹€æ…‹ï¼Œè³­åšç²å¾— 300 é‡‘å¹£æˆ–æ“Šæ•—å¼·æ•µç²å–éš¨æ©Ÿè¢«å‹•ï¼Ÿ")) {
        player.hp = Math.max(1, Math.floor(player.hp * 0.5));
        player.mp = Math.floor(player.mp * 0.5);
        if(Math.random() < 0.5) {
            gold += 350; addLog("âœ¨ ç¥­å£‡ç¥è·¡ï¼ç²å¾— 350 é‡‘å¹£");
        } else {
            addLog("ğŸ’€ ç¥­å£‡å´©å¡Œï¼å®ˆè¡›å‡ºç¾ï¼", "red");
            spawnEnemy(true, Math.floor(floor/10)*40);
        }
        updateUI();
    }
}

function openModal() {
    if(currentBuilding.type === "ç¥­å£‡") { useAltar(); return; }
    const m = document.getElementById('building-ui');
    const c = document.getElementById('modal-content');
    document.getElementById('modal-title').innerText = "ğŸ›ï¸ " + currentBuilding.type;
    m.style.display = 'block';
    c.innerHTML = "";
    currentBuilding.items.forEach((it, idx) => {
        let div = document.createElement('div'); div.className = "btn-opt";
        div.innerHTML = `<div><b>${it.n}</b><br><small>${it.d||''}</small></div><span style="color:var(--accent)">ğŸ’°${it.p}</span>`;
        div.onclick = () => {
            if(gold >= it.p) {
                gold -= it.p; it.f();
                if(!it.inf) currentBuilding.items.splice(idx, 1);
                updateUI(); openModal();
            }
        };
        c.appendChild(div);
    });
}

function draw() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,750,600);
    for(let y=0; y<GH; y++) for(let x=0; x<GW; x++) {
        if(dungeon[y][x] === 1) { ctx.fillStyle="#1a1a1a"; ctx.fillRect(x*TILE+1, y*TILE+1, TILE-2, TILE-2); }
        if(dungeon[y][x] === 2) { ctx.font="20px Arial"; ctx.fillText("ğŸªœ", x*TILE+4, y*TILE+23); }
        if(dungeon[y][x] === 3) { 
            const icon = {"éµåŒ é‹ª":"âš’ï¸","é­”æ³•å•†åº—":"ğŸ”®","é“å…·åº—":"ğŸ±","ç¥­å£‡":"â›©ï¸","è¨“ç·´å ´":"ğŸ‹ï¸"};
            ctx.fillText(icon[currentBuilding.type]||"ğŸ ", x*TILE+4, y*TILE+23);
        }
    }

    enemies.forEach(en => {
        ctx.fillStyle = en.color;
        const cx = en.x*TILE+15, cy = en.y*TILE+15;
        if(en.shape === "square") ctx.fillRect(en.x*TILE+6, en.y*TILE+6, 18, 18);
        else if(en.shape === "circle") { ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill(); }
        else if(en.shape === "diamond") {
            ctx.beginPath(); ctx.moveTo(cx, cy-12); ctx.lineTo(cx+12, cy); ctx.lineTo(cx, cy+12); ctx.lineTo(cx-12, cy); ctx.closePath(); ctx.fill();
        }
        if(en.isElite) { ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke(); ctx.shadowBlur=10; ctx.shadowColor="#fff"; }
        ctx.shadowBlur=0;
        
        if(en.lastHit > 0) {
            ctx.fillStyle="#333"; ctx.fillRect(en.x*TILE, en.y*TILE-5, TILE, 4);
            ctx.fillStyle="#2ecc71"; ctx.fillRect(en.x*TILE, en.y*TILE-5, TILE*(en.hp/en.maxHp), 4);
            en.lastHit--;
        }
    });

    ctx.fillStyle = "#3498db";
    ctx.beginPath(); ctx.moveTo(player.x*TILE+15, player.y*TILE+2); ctx.lineTo(player.x*TILE+28, player.y*TILE+15);
    ctx.lineTo(player.x*TILE+15, player.y*TILE+28); ctx.lineTo(player.x*TILE+2, player.y*TILE+15);
    ctx.closePath(); ctx.fill();

    effects.forEach((eff, i) => {
        ctx.globalAlpha = eff.l/10; ctx.fillStyle="#f1c40f"; ctx.fillRect(eff.x*TILE, eff.y*TILE, TILE, TILE);
        eff.l--; if(eff.l<=0) effects.splice(i,1);
    });
    ctx.globalAlpha = 1;
}

function dealDamage(t, base, key) {
    let sc = key ? SPELLS[key].sc : 1;
    let dmg = Math.floor((key ? player.mgk : player.atk) * sc);
    t.hp -= dmg; t.lastHit = 15;
    addLog(`âš”ï¸ [${key?SPELLS[key].n:'è¿‘æˆ°'}] å° [${t.name}] é€ æˆ ${dmg} å‚·å®³`);
    if(passives.includes("å¸è¡€") && !key) player.hp = Math.min(player.maxHp, player.hp + 3);
    if(t.hp <= 0) {
        gold += (t.isElite?180:25); gainExp(t.isElite?350:50);
        if(t.isElite && currentBuilding.type === "ç¥­å£‡") {
            const pArr = Object.keys(PASSIVE_DATA).filter(p=>!passives.includes(p));
            if(pArr.length){
                let p = pArr[Math.floor(Math.random()*pArr.length)];
                passives.push(p); addLog(`ğŸ† æ“Šæ•—å®ˆè¡›ç²å¾—è¢«å‹•ï¼š${p}`);
            }
        }
        enemies = enemies.filter(e => e !== t);
    }
}

function endTurn() {
    Object.keys(player.cd).forEach(k => { if(player.cd[k]>0) player.cd[k]--; });
    if(passives.includes("å†¥æƒ³")) player.mp = Math.min(player.maxMp, player.mp + 1);
    enemies.forEach(en => {
        let dist = Math.abs(player.x-en.x) + Math.abs(player.y-en.y);
        if(dist === 1) {
            let rawDmg = Math.max(1, en.atk - player.def);
            if(passives.includes("æ³•åŠ›è­·ç›¾") && Math.random() < 0.4) rawDmg = Math.floor(rawDmg * 0.7);
            player.hp -= rawDmg; addLog(`ğŸ‘º [${en.name}] é€ æˆ ${rawDmg} å‚·å®³`, "red");
            if(passives.includes("èŠæ£˜")) en.hp -= Math.floor(rawDmg*0.5);
        } else {
            let dx = Math.sign(player.x-en.x), dy = Math.sign(player.y-en.y);
            if(dungeon[en.y+dy][en.x+dx]===0 && !enemies.some(e=>e.x===en.x+dx && e.y===en.y+dy)) {
                en.x += dx; en.y += dy;
            }
        }
    });
    if(player.hp <= 0) { alert("æˆ°æ•—ï¼æŠµé”ç¬¬ " + floor + " å±¤"); location.reload(); }
    updateUI();
}

function updateUI() {
    document.getElementById('s-hp').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
    document.getElementById('s-mp').innerText = `${Math.floor(player.mp)}/${player.maxMp}`;
    document.getElementById('s-atk').innerText = player.atk;
    document.getElementById('s-mgk').innerText = player.mgk;
    document.getElementById('s-def').innerText = player.def;
    document.getElementById('s-gold').innerText = gold;
    document.getElementById('s-floor').innerText = floor;
    document.getElementById('s-lv').innerText = lv;
    document.getElementById('exp-bar').style.width = (exp/nextExp)*100 + "%";
    
    let pUI = document.getElementById('passive-ui'); pUI.innerHTML = "";
    passives.forEach(p => {
        pUI.innerHTML += `<div class="passive-tag">${p}: ${PASSIVE_DATA[p].desc}</div>`;
    });
    
    let sUI = document.getElementById('spell-ui'); sUI.innerHTML = "";
    playerSpells.forEach(k => {
        let s = SPELLS[k];
        sUI.innerHTML += `<div style="background:#252525; padding:8px; border-radius:4px; margin-top:5px; border:1px solid #444;">
            <b>[${k}] ${s.n}</b> (MP:${s.mp}) <span style="float:right">${player.cd[k]?'â³'+player.cd[k]:'âœ…'}</span><br>
            <small>${s.d} | ä¿‚æ•¸:${s.sc}x</small></div>`;
    });
}

function gainExp(a) {
    exp += a; if(exp >= nextExp) { 
        lv++; exp -= nextExp; nextExp = Math.floor(nextExp * 1.5); 
        player.maxHp += 25; player.maxMp += 15; player.hp = player.maxHp; 
    }
}

function addLog(m, c) {
    let d = document.createElement('div'); if(c==="red") d.style.color="#ff4757";
    d.innerText = "> " + m; let l = document.getElementById('log'); l.prepend(d);
}

function closeModal() { document.getElementById('building-ui').style.display = 'none'; }

function tryMove(dx, dy) {
    let nx = player.x + dx, ny = player.y + dy;
    if (nx < 0 || nx >= GW || ny < 0 || ny >= GH || dungeon[ny][nx] === 1) return;
    let target = enemies.find(e => e.x === nx && e.y === ny);
    if (target) { dealDamage(target, player.atk, null); endTurn(); }
    else {
        player.x = nx; player.y = ny;
        if(dungeon[ny][nx] === 2) { floor++; initLevel(); }
        if(dungeon[ny][nx] === 3) openModal();
        else endTurn();
    }
}

window.addEventListener('keydown', e => {
    if(document.getElementById('building-ui').style.display === 'block') return;
    let k = e.key.toUpperCase();
    if(['W','A','S','D'].includes(k)) {
        if(k==='W') tryMove(0,-1); if(k==='S') tryMove(0,1);
        if(k==='A') tryMove(-1,0); if(k==='D') tryMove(1,0);
    } else if(SPELLS[k] && playerSpells.includes(k)) {
        if(player.mp >= SPELLS[k].mp && !player.cd[k]) {
            player.mp -= SPELLS[k].mp; player.cd[k] = SPELLS[k].cd;
            if(k==='Q') {
                [[0,-1],[0,1],[-1,0],[1,0]].forEach(d => {
                    for(let i=1; i<6; i++) {
                        let tx = player.x+d[0]*i, ty = player.y+d[1]*i;
                        if(dungeon[ty][tx]===1) break;
                        effects.push({x:tx, y:ty, l:5});
                        let t = enemies.find(e=>e.x===tx && e.y===ty);
                        if(t) { dealDamage(t, 0, 'Q'); break; }
                    }
                });
            } else if(k==='V') { player.hp = Math.min(player.maxHp, player.hp+35); }
            else { enemies.forEach(en => { effects.push({x:en.x, y:en.y, l:8}); dealDamage(en, 0, k); }); }
            endTurn();
        }
    }
});

initLevel();
setInterval(draw, 50);
</script>
</body>
</html>
