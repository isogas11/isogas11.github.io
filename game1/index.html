<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <title>æ·±æ·µçµæ‰‹</title>
    <style>
        :root {
            --bg: #050505;
            --ui: #1c1c1c;
            --border: #3498db;
            --accent: #f1c40f;
            --danger: #e74c3c;
            --win: #2ecc71;
        }

        * {
            box-sizing: border-box;
        }

        body {
            background: var(--bg);
            color: #eee;
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            margin: 0;
            padding: 10px;
            display: flex;
            justify-content: center;
            overflow: hidden;
            height: 100vh;
        }

        .game-wrapper {
            display: flex;
            gap: 10px;
            width: 100%;
            height: 100%;
            max-width: 1600px;
        }

        .sidebar-left {
            width: 330px;
            background: var(--ui);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #game-area {
            border: 4px solid #3498db;
            background: #000;
            cursor: crosshair;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.2);
        }

        .sidebar-right {
            width: 280px;
            background: var(--ui);
            border: 2px solid var(--danger);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .log-container {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
            font-size: 13px;
            padding: 8px;
            border: 1px solid #444;
            line-height: 1.5;
        }

        .skill-item {
            background: #222;
            border: 1px solid #9b59b6;
            border-radius: 4px;
            padding: 4px 8px;
            margin-bottom: 3px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
        }

        .skill-name {
            color: var(--accent);
            font-weight: bold;
            flex: 1;
        }

        .skill-stat {
            margin-left: 8px;
            font-family: monospace;
        }

        .passive-item {
            border-left: 3px solid var(--win);
            background: rgba(46, 204, 113, 0.1);
            padding: 2px 8px;
            margin: 2px 0;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 480px;
            background: #222;
            border: 3px solid var(--accent);
            padding: 20px;
            display: none;
            z-index: 1000;
            border-radius: 10px;
        }

        .btn-opt {
            background: #333;
            color: #fff;
            padding: 12px;
            margin: 8px 0;
            width: 100%;
            text-align: left;
            cursor: pointer;
            border: 1px solid #555;
        }

        .btn-opt:hover {
            border-color: var(--accent);
            background: #3d3d3d;
        }

        .exp-container {
            width: 100%;
            background: #222;
            height: 6px;
            border-radius: 7px;
            margin: 8px 0;
            border: 1px solid #444;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        #exp-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #3498db, #9b59b6);
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
            transition: width 0.4s ease-out;
        }
    </style>
</head>

<body>
    <div id="game-modal" class="modal">
        <h3 id="modal-title" style="color:var(--accent); text-align:center;">å•†åº—</h3>
        <div id="modal-content"></div>
        <button onclick="closeModal()"
            style="width:100%; padding:10px; cursor:pointer; background:var(--danger); color:white; border:none; margin-top:10px;">é›¢é–‹</button>
    </div>
    <div class="game-wrapper">
        <div class="sidebar-left">
            <h4 style="text-align:center; margin:5px 0; color:var(--border);">ç¬¬ <span id="s-floor">1</span> å±¤</h4>
            <div
                style="background:#222; border:1px solid var(--win); border-radius:5px; padding:8px; margin-bottom:10px; text-align:center;">
                <div style="font-size:11px; color:var(--win);">ğŸƒ å¿«é€Ÿé—–é—œçå‹µ</div>
                <div id="s-bonus" style="font-size:20px; font-weight:bold; color:var(--win);">200</div>
            </div>
            <h4 style="text-align:center; margin:0; color:var(--accent);">LV. <span id="s-lv">1</span></h4>
            <div class="exp-container">
                <div id="exp-fill"></div>
            </div>
            <div style="text-align: center; font-size: 11px; color: #aaa; margin-top: -5px; margin-bottom: 10px;">EXP:
                <span id="s-exp-val">0 / 100</span>
            </div>
            <div class="stat-line"><span>â¤ï¸ ç”Ÿå‘½</span> <span id="s-hp" class="val">100/100</span></div>
            <div class="stat-line"><span>ğŸ§ª é­”åŠ›</span> <span id="s-mp" class="val">40/40</span></div>
            <div class="stat-line"><span>âš”ï¸ ç‰©æ”»</span> <span id="s-atk" class="val">10</span></div>
            <div class="stat-line"><span>ğŸ”® é­”æ”»</span> <span id="s-mgk" class="val">10</span></div>
            <div class="stat-line"><span>ğŸ›¡ï¸ é˜²ç¦¦</span> <span id="s-def" class="val">5</span></div>
            <div class="stat-line"><span>ğŸ’° é‡‘å¹£</span> <span id="s-gold" class="val">200</span></div>
            <div class="section-title" style="color:var(--accent); border-bottom:1px solid #444; margin-top:10px;">ğŸ”®
                æŠ€èƒ½å¿«æ·éµ</div>
            <div id="skill-list"></div>
            <div class="section-title" style="color:var(--win); border-bottom:1px solid #444; margin-top:10px;">ğŸ§¬ æ°¸ä¹…è¢«å‹•
            </div>
            <div id="passive-list"></div>
        </div>
        <div class="main-area">
            <div id="game-area"><canvas id="gameCanvas"></canvas></div>
        </div>
        <div class="sidebar-right">
            <h4 style="margin:0 0 5px 0; color:var(--danger);">âš”ï¸ æˆ°é¬¥æ•¸æ“šæ—¥èªŒ</h4>
            <div id="log-box" class="log-container"></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE = 28, GW = 40, GH = 30;
        canvas.width = GW * TILE; canvas.height = GH * TILE;
        let floor = 1, gold = 200, lv = 1, exp = 0, nextExp = 100, tick = 0, floorBonus = 100;
        let dungeon = [], enemies = [], effects = [], buildings = [], stairs = [], traps = [];
        let player = { x: 20, y: 15, maxHp: 100, hp: 100, maxMp: 30, mp: 30, atk: 12, def: 5, mgk: 12, steps: 0, cd: {}, history: [] };
        //åˆå§‹æŠ€èƒ½
        let playerSpells = ['Q'], ownedPassives = [], priceScales = { atk: 60, mgk: 60, def: 60, maxMp: 50 };
        const SPELL_DATA = {
            'Q': { n: 'ç«ç„°è¡“', mp: 3, cd: 3, sc: 1.4, type: 'mgk', eff: 'åå­—æ”»æ“Š' },
            'E': { n: 'å†°çˆ†è¡“', mp: 7, cd: 8, sc: 1.2, type: 'mgk', eff: '5x5 å‡çµ' },
            'F': { n: 'è¬åŠè¨£', mp: 24, cd: 14, sc: 1, type: 'atk', eff: 'é‡æ“Šå…¨éƒ¨æ•µäºº' },
            'R': { n: 'æœ«æ—¥å¯©åˆ¤', mp: 30, cd: 20, sc: 1.2, type: 'mgk', eff: 'æ¯€æ»…å…¨éƒ¨æ•µäºº' },
            'V': { n: 'è–å…‰æ²»ç™’', mp: 5, cd: 16, sc: 2.0, type: 'heal', eff: 'å¤§é‡å›è¡€' },
            'G': { n: 'æ™‚ç©ºå›æº¯', mp: 5, cd: 12, sc: 0, type: 'move', eff: 'å›åˆ° 10 æ­¥å‰' },
            'X': { n: 'å¥§è¡“åœ°é›·', mp: 5, cd: 5, sc: 2.5, type: 'trap', eff: 'åŸåœ°åŸ‹é›·' }
        };
        const PASSIVE_POOL = [
            { id: "p1", n: "ğŸ©¸ å—œè¡€", d: "æ¯æ¬¡æ™®æ”»å‘½ä¸­å›å¾© 1 HP" },
            { id: "p2", n: "ğŸ§˜ å†¥æƒ³", d: "æ¯å±¤å‚³é€é¡å¤–å› 30 MP" },
            { id: "p3", n: "âš¡ è¿…æ·", d: "æŠ€èƒ½å†·å»ç¸®çŸ­ 2 å›åˆ" },
            { id: "p4", n: "ğŸ¯ ç²¾æº–", d: "20% æ©Ÿç‡é€ æˆ 2 å€æš´æ“Šå‚·å®³" },
            { id: "p5", n: "ğŸ± æ‹›è²¡", d: "ç²å¾—çš„é‡‘å¹£æ•¸é‡æå‡ 50%" },
            { id: "p8", n: "ğŸ”¥ é­”æ³•å¼·åŒ–", d: "æŠ€èƒ½å‚·å®³æ•ˆæœæå‡ 20%" },
            { id: "p9", n: "âœ¨ é­”åŠ›é™„é­”", d: "æ™®æ”»é¡å¤–ç²å¾— 50% é­”æ”»å‚·å®³" },
            { id: "p10", n: "ğŸ’§ æ±²å–é­”åŠ›", d: "æ¯èµ° 5 æ­¥è·¯å›å¾© 5% é­”åŠ›" }
        ];
        //åˆå§‹è¢«å‹•
        ownedPassives = [PASSIVE_POOL.find(p => p.id === "p10")];

        function addLog(msg, color = "#eee") {
            const box = document.getElementById('log-box');
            const entry = document.createElement('div');
            entry.style.color = color; entry.innerHTML = msg;
            box.prepend(entry);
            if (box.childNodes.length > 40) box.removeChild(box.lastChild);
        }
        function updateUI() {
            document.getElementById('s-lv').innerText = lv;
            document.getElementById('s-floor').innerText = floor;
            document.getElementById('s-hp').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById('s-mp').innerText = `${Math.floor(player.mp)}/${player.maxMp}`;
            document.getElementById('s-atk').innerText = player.atk;
            document.getElementById('s-mgk').innerText = player.mgk;
            document.getElementById('s-def').innerText = player.def;
            document.getElementById('s-gold').innerText = gold;
            document.getElementById('s-bonus').innerText = floorBonus;
            const currentExp = exp || 0;
            const goalExp = nextExp || 100;
            const expPercent = Math.min(100, (currentExp / goalExp) * 100);
            const fillElem = document.getElementById('exp-fill');
            const valElem = document.getElementById('s-exp-val');
            if (fillElem) fillElem.style.width = (isNaN(expPercent) ? 0 : expPercent) + "%";
            if (valElem) valElem.innerText = `${Math.floor(currentExp)} / ${goalExp}`;
            const sList = document.getElementById('skill-list');
            if (sList) {
                sList.innerHTML = "";
                playerSpells.forEach(key => {
                    const s = SPELL_DATA[key];
                    const bonus = ownedPassives.some(p => p.id === "p8") ? 1.2 : 1.0;
                    let powerVal = "--", powerColor = "var(--danger)";
                    if (key === 'F') {
                        const res = calcAttackDmg(s.sc, true);
                        powerVal = res.total;
                        if (res.isMagic) powerColor = "#9b59b6";
                    } else if (s.type === 'mgk') {
                        powerVal = Math.floor(player.mgk * s.sc * bonus);
                        powerColor = "#3498db";
                    } else if (s.type === 'atk') {
                        powerVal = Math.floor(player.atk * s.sc);
                    } else if (s.type === 'heal') {
                        powerVal = Math.floor(player.mgk * s.sc * bonus);
                        powerColor = "var(--win)";
                    }
                    const isCD = (player.cd[key] || 0) > 0;
                    sList.innerHTML += `<div class="skill-item" style="opacity: ${isCD ? 0.5 : 1}; border-color: ${isCD ? '#444' : (key === 'F' && powerColor === "#9b59b6" ? "#9b59b6" : "#9b59b6")};"><span class="skill-name">[${key}] ${s.n}</span><span class="skill-stat" style="color:#3498db">ğŸ’§${s.mp}</span><span class="skill-stat" style="color:${powerColor}">ğŸ’¥${powerVal}</span>${isCD ? `<span class="skill-stat" style="color:var(--accent)">â³${player.cd[key]}</span>` : ''}</div>`;
                });
            }
            const pList = document.getElementById('passive-list');
            if (pList) {
                pList.innerHTML = "";
                ownedPassives.forEach(p => { pList.innerHTML += `<div class="passive-item" title="${p.d}"><b>${p.n}</b></div>`; });
            }
        }
        function initLevel() {
            dungeon = Array(GH).fill().map(() => Array(GW).fill(1));
            enemies = []; buildings = []; stairs = []; traps = [];
            floorBonus = 100 + (floor * 20);
            let cx = 20, cy = 15, walkables = [];
            for (let i = 0; i < 1800; i++) {
                dungeon[cy][cx] = 0; walkables.push({ x: cx, y: cy });
                let d = Math.floor(Math.random() * 4);
                if (d === 0 && cy > 2) cy--; else if (d === 1 && cy < GH - 3) cy++;
                else if (d === 2 && cx > 2) cx--; else if (d === 3 && cx < GW - 3) cx++;
            }
            player.x = 20; player.y = 15;
            player.history = Array(10).fill({ x: 20, y: 15 });
            let farPos = walkables.sort((a, b) => (Math.abs(b.x - 20) + Math.abs(b.y - 15)) - (Math.abs(a.x - 20) + Math.abs(a.y - 15)))[0];
            stairs.push({ x: farPos.x, y: farPos.y });
            stairs.push({ x: walkables[Math.floor(Math.random() * walkables.length)].x, y: walkables[Math.floor(Math.random() * walkables.length)].y });
            spawnBuilding(["é“å…·åº—", "éµåŒ é‹ª", "é­”æ³•å•†åº—", "è¨“ç·´æ‰€"][(floor - 1) % 4]);
            if (floor % 10 === 0) {
                let p = walkables[Math.floor(Math.random() * walkables.length)];
                enemies.push({ x: p.x, y: p.y, hp: 400 + floor * 120, maxHp: 400 + floor * 120, atk: 5 + floor * 1.6, emoji: "ğŸ‰", type: "boss", freeze: 0 });
                addLog(`ğŸ“¢ è­¦å‘Šï¼šå®ˆå±¤ BOSS å·²ç¶“å‡ºç¾ï¼`, "#e74c3c");
            }
            if (floor % 5 === 0) {
                for (let i = 0; i < Math.floor(floor / 5); i++) {
                    let p = walkables[Math.floor(Math.random() * walkables.length)];
                    enemies.push({ x: p.x, y: p.y, hp: floor * 50, maxHp: floor * 50, atk: 8 + floor * 1.4, emoji: "ğŸ’€", type: "elite", freeze: 0 });
                }
            }
            for (let i = 0; i < 10; i++) {
                let p = walkables[Math.floor(Math.random() * walkables.length)];
                if (p.x === 20 && p.y === 15) continue;
                enemies.push({ x: p.x, y: p.y, hp: 20 + floor * 6, maxHp: 30 + floor * 6, atk: 5 + floor *1.2, emoji: "ğŸ‘¹", type: "normal", freeze: 0 });
            }
            updateUI();
        }
        function spawnBuilding(type) {
            const icons = { "é“å…·åº—": "ğŸ±", "éµåŒ é‹ª": "âš’ï¸", "é­”æ³•å•†åº—": "ğŸ”®", "è¨“ç·´æ‰€": "âš”ï¸" };
            let rx, ry;
            do { rx = Math.floor(Math.random() * GW); ry = Math.floor(Math.random() * GH); } while (dungeon[ry][rx] !== 0 || Math.abs(rx - 20) < 5);
            buildings.push({ x: rx, y: ry, type, icon: icons[type] });
        }
        function movePlayer(dx, dy) {
            let nx = player.x + dx, ny = player.y + dy;
            if (nx < 0 || nx >= GW || ny < 0 || ny >= GH) return;
            if (floorBonus > 0) floorBonus--;
            let en = enemies.find(e => e.x === nx && e.y === ny);
            if (en) {
                const res = calcAttackDmg(1.0);
                en.hp -= res.total;

                // å½ˆå‡ºå‚·å®³æ•¸å€¼ (ç™½è‰²)
                effects.push({
                    x: en.x, y: en.y,
                    l: 20,
                    c: "#ffffff",
                    type: 'text',
                    txt: res.total
                });

                if (res.isCrit) {
                    // æš´æ“Šæ™‚é¡å¤–åœ¨æ›´é«˜ä¸€é»çš„ä½ç½®å½ˆå‡ºé»ƒè‰² CRIT!!
                    effects.push({
                        x: en.x, y: en.y - 0.4,
                        l: 25, c: "#f1c40f",
                        type: 'text', txt: "CRIT!!"
                    });
                    addLog(`ğŸ¯ æš´æ“Šï¼é€ æˆ ${res.total} å‚·å®³`, "#f1c40f");
                }

                addLog(`âš”ï¸ ä½ å°æ€ªç‰©é€ æˆ ${res.total} å‚·å®³`);
                if (ownedPassives.some(p => p.id === "p1")) player.hp = Math.min(player.maxHp, player.hp + 1);
                checkDeath(en); endTurn(); return;
            }
            if (buildings.some(b => b.x === nx && b.y === ny)) { openModal(buildings.find(b => b.x === nx && b.y === ny)); return; }
            if (stairs.some(s => s.x === nx && s.y === ny)) {
                if (floorBonus > 0) {
                    let gain = floorBonus;
                    gold += gain; exp += gain;
                    addLog(`ğŸŠ å¿«é€Ÿé—–é—œçå‹µ +${gain}ï¼`, "#2ecc71");
                }
            // --- å†¥æƒ³çš„é‚è¼¯ ---
                if (ownedPassives.some(p => p.id === "p2")) {
                    player.mp = Math.min(player.maxMp, player.mp + 30);
                    addLog(`ğŸ§˜ å†¥æƒ³è§¸ç™¼ï¼šå›å¾© 30 MP`, "#3498db");
                    // å½ˆå€‹æ•¸å­—åœ¨é ­ä¸Š
                    effects.push({ x: player.x, y: player.y, l: 60, c: "#3498db", type: 'text', txt: "+30 MP" });
                }
                // -------------------------
                player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.1);
                player.mp = Math.min(player.maxMp, player.mp + player.maxMp * 0.1);
                floor++; initLevel(); return;
            }
            if (dungeon[ny][nx] === 0) {
                player.history.push({ x: player.x, y: player.y });
                if (player.history.length > 10) player.history.shift();
                player.x = nx; player.y = ny;
                // --- æ–°å¢å›é­”é‚è¼¯ ---
                if (ownedPassives.some(p => p.id === "p10")) {
                    player.steps++;
                    if (player.steps >= 5) {
                        let recovery = Math.max(1, Math.floor(player.maxMp * 0.05));
                        player.mp = Math.min(player.maxMp, player.mp + recovery);

                        // å½ˆå‡ºè—è‰²æ•¸å­—æç¤ºå›é­”
                        effects.push({
                            x: player.x, y: player.y,
                            l: 60, c: "#3498db",
                            type: 'text', txt: `+${recovery} MP`
                        });

                        player.steps = 0; // é‡ç½®æ­¥æ•¸
                    }
                }
                // ------------------

                endTurn();
            }
        }
        function castSpell(key) {
            const s = SPELL_DATA[key];
            if (!playerSpells.includes(key) || player.mp < s.mp || (player.cd[key] || 0) > 0) return;
            if (floorBonus > 0) floorBonus--;
            player.mp -= s.mp;
            player.cd[key] = s.cd - (ownedPassives.some(p => p.id === "p3") ? 2 : 0);
            const bonus = ownedPassives.some(p => p.id === "p8") ? 1.2 : 1.0;
            if (key === 'F') {
                enemies.forEach(en => {
                    // 1. è¨ˆç®—å‚·å®³ (åŒ…å«æš´æ“Šåˆ¤æ–·)
                    const res = calcAttackDmg(s.sc);
                    en.hp -= res.total;

                    if (ownedPassives.some(p => p.id === "p1")) player.hp = Math.min(player.maxHp, player.hp + 1);

                    // 2. é¡¯ç¤ºæ–¹å¡Šç‰¹æ•ˆ (è¬åŠè¨£çš„è¦–è¦º)
                    effects.push({
                        x: en.x, y: en.y, l: 10,
                        c: res.isMagic ? "#9b59b6" : "#fff",
                        type: 'square'
                    });

                    // 3. å™´å‡ºå‚·å®³æ•¸å­— (ç™½è‰²æˆ–ç´«è‰²)
                    effects.push({
                        x: en.x, y: en.y, l: 20,
                        c: res.isMagic ? "#9b59b6" : "#ffffff",
                        type: 'text', txt: res.total
                    });

                    // 4. å¦‚æœæ˜¯æš´æ“Šï¼Œé¡å¤–å™´å‡ºé‡‘è‰²çš„ CRIT!!
                    if (res.isCrit) {
                        effects.push({
                            x: en.x, y: en.y - 0.4, l: 25,
                            c: "#f1c40f", type: 'text', txt: "CRIT!!"
                        });
                    }
                });
                enemies.forEach(en => checkDeath(en));
                addLog(`âœ¨ è¬åŠè¨£ï¼`, "#9b59b6");
            } else if (key === 'R') {
                enemies.forEach(en => {
                    let dmg = Math.floor(player.mgk * s.sc * bonus); // æå–å‚·å®³è®Šæ•¸
                    en.hp -= dmg;
                    effects.push({ x: en.x, y: en.y, l: 20, c: "#ff4757", type: 'text', txt: dmg }); // å½ˆå‡ºæ•¸å­—
                });
                enemies.forEach(en => checkDeath(en));
                addLog(`â˜„ï¸ æœ«æ—¥å¯©åˆ¤ï¼é™ä¸‹å¤©ç«`, "#e74c3c");
            } else if (key === 'E') {
                addLog(`â„ï¸ å†°çˆ†è¡“ï¼`, "#3498db");
                for (let iy = -2; iy <= 2; iy++) {
                    for (let ix = -2; ix <= 2; ix++) {
                        let life = 15 - (Math.abs(ix) + Math.abs(iy)) * 2;
                        effects.push({ x: player.x + ix, y: player.y + iy, l: life, c: "#3498db", type: 'square' });
                    }
                }
                enemies.forEach(en => {
                    if (Math.abs(en.x - player.x) <= 2 && Math.abs(en.y - player.y) <= 2) {
                        let dmg = Math.floor(player.mgk * s.sc * bonus);
                        en.hp -= dmg;
                        effects.push({ x: en.x, y: en.y, l: 20, c: "#ff4757", type: 'text', txt: dmg }); // å½ˆå‡ºæ•¸å­—
                        en.freeze = 4;
                    }
                });
                enemies.forEach(en => checkDeath(en));
            } else if (key === 'Q') {
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(d => {
                    for (let i = 1; i <= 4; i++) {
                        let tx = player.x + d[0] * i, ty = player.y + d[1] * i;
                        effects.push({ x: tx, y: ty, l: 10, c: "#e67e22", type: 'square' });
                        let tar = enemies.find(e => e.x === tx && e.y === ty);
                        if (tar) {
                            let dmg = Math.floor(player.mgk * s.sc * bonus);
                            tar.hp -= dmg;
                            effects.push({ x: tar.x, y: tar.y, l: 20, c: "#ff4757", type: 'text', txt: dmg }); // å½ˆå‡ºæ•¸å­—
                            break;
                        }
                    }
                });
                enemies.forEach(en => checkDeath(en));
            } else if (key === 'V') {
                player.hp = Math.min(player.maxHp, player.hp + player.mgk * 2 * bonus);
                effects.push({ x: player.x, y: player.y, l: 20, c: "#2ecc71", type: 'square' });
            } else if (key === 'G') {
                let back = player.history[0]; player.x = back.x; player.y = back.y;
            } else if (key === 'X') {
                traps.push({ x: player.x, y: player.y, dmg: Math.floor(player.mgk * s.sc * bonus) });
            }
            endTurn();
        }
        function checkDeath(en) {
            if (en.hp <= 0) {
                let gain = en.type === 'boss' ? 1000 : (en.type === 'elite' ? 50 : 10);
                if (ownedPassives.some(p => p.id === "p5")) gain = Math.floor(gain * 1.5);
                gold += gain; exp += gain;
                enemies = enemies.filter(e => e !== en);
                addLog(`ğŸ’€ æ“Šæ®º ${en.emoji} ç²å¾— ${gain}G`, "#2ecc71");
            }
        }
        function calcAttackDmg(baseScale = 1.0, isPredict = false) {
            let dmg = player.atk * baseScale;
            let details = { isCrit: false, isMagic: false, magicDmg: 0 };
            if (!isPredict && ownedPassives.some(p => p.id === "p4") && Math.random() < 0.2) {
                dmg *= 2; details.isCrit = true;
            }
            if (ownedPassives.some(p => p.id === "p9")) {
                details.magicDmg = Math.floor(player.mgk * 0.5);
                dmg += details.magicDmg; details.isMagic = true;
            }
            return { total: Math.floor(dmg), isCrit: details.isCrit, isMagic: details.isMagic, magicDmg: details.magicDmg };
        }
        function endTurn() {
            Object.keys(player.cd).forEach(k => { if (player.cd[k] > 0) player.cd[k]--; });
            enemies.forEach(en => {
                traps.forEach((t, ti) => {
                    if (en.x === t.x && en.y === t.y) {
                        enemies.forEach(targetEn => {
                            if (Math.abs(targetEn.x - t.x) <= 1 && Math.abs(targetEn.y - t.y) <= 1) {
                                targetEn.hp -= t.dmg;
                                effects.push({ x: targetEn.x, y: targetEn.y, l: 20, c: "#9b59b6", type: 'text', txt: t.dmg });
                            }
                        });
                        effects.push({ x: t.x, y: t.y, l: 15, c: "#9b59b6", type: 'mine_exp' });
                        traps.splice(ti, 1);
                        addLog("ğŸ’¥ å¥§è¡“åœ°é›·å¼•çˆ†ï¼(3x3 ç¯„åœå‚·å®³)", "#9b59b6");
                    }
                });
                enemies.forEach(en => checkDeath(en));
                if (!en || en.freeze > 0) { if (en) en.freeze--; return; }
                let dist = Math.abs(player.x - en.x) + Math.abs(player.y - en.y);
                if (dist === 1) {
                    let dmg = Math.max(1, en.atk - player.def);
                    player.hp -= dmg;
                    addLog(`ğŸ’” å—åˆ°æ€ªç‰©æ”»æ“Šï¼š-${dmg} HP`, "#e74c3c");
                } else if (dist < 7) {
                    let mx = Math.sign(player.x - en.x), my = Math.sign(player.y - en.y);
                    if (mx !== 0 && dungeon[en.y][en.x + mx] === 0 && !enemies.some(e => e.x === en.x + mx && e.y === en.y)) en.x += mx;
                    else if (my !== 0 && dungeon[en.y + my][en.x] === 0 && !enemies.some(e => e.x === en.x && e.y === en.y + my)) en.y += my;
                }
            });
            if (exp >= nextExp) {
                lv++; exp = 0; nextExp = Math.floor(nextExp * 1.6); player.maxHp += 20; player.maxMp += 5;
                player.hp = player.maxHp; player.mp = player.maxMp; addLog("ğŸŒŸ Level Up!", "#f1c40f");
            }
            if (player.hp <= 0) { alert("å†’éšªçµæŸ..."); location.reload(); }
            updateUI();
        }
        function openModal(b) {
            const m = document.getElementById('game-modal'); const c = document.getElementById('modal-content');
            m.style.display = 'block'; c.innerHTML = ""; document.getElementById('modal-title').innerText = b.type;
            let opts = [];
            if (b.type === "éµåŒ é‹ª") {
                opts = [
                    { n: "å¼·åŒ–åŠ›é‡ (+5 ATK)", p: priceScales.atk, f: () => { player.atk += 5; priceScales.atk += 25 } },
                    { n: "å¼·åŒ–é­”æ³• (+5 MGK)", p: priceScales.mgk, f: () => { player.mgk += 5; priceScales.mgk += 25 } },
                    { n: "å¼·åŒ–é˜²ç¦¦ (+3 DEF)", p: priceScales.def, f: () => { player.def += 3; priceScales.def += 25 } },
                    { n: "é­”åŠ›ä¸Šé™ (+5 MP)", p: priceScales.maxMp, f: () => { player.maxMp += 5; priceScales.maxMp += 20 } }
                ];
            } else if (b.type === "é“å…·åº—") {
                opts = [
                    { n: "ç”Ÿå‘½éˆè—¥ (+60 HP)", p: 30, f: () => player.hp = Math.min(player.maxHp, player.hp + 60) },
                    { n: "é­”åŠ›è—¥æ°´ (+20 MP)", p: 30, f: () => player.mp = Math.min(player.maxMp, player.mp + 20) }
                ];
            } else if (b.type === "é­”æ³•å•†åº—") {
                Object.keys(SPELL_DATA).filter(k => !playerSpells.includes(k)).forEach(k => {
                    opts.push({ n: `[${k}] ${SPELL_DATA[k].n}`, d: SPELL_DATA[k].eff, p: 250, f: () => playerSpells.push(k) });
                });
            } else if (b.type === "è¨“ç·´æ‰€") {
                PASSIVE_POOL.filter(p => !ownedPassives.some(op => op.id === p.id)).forEach(p => {
                    opts.push({ n: p.n, d: p.d, p: 0, f: () => { ownedPassives.push(p); buildings = buildings.filter(x => x !== b); closeModal(); } });
                });
            }
            opts.forEach(it => {
                let btn = document.createElement('div'); btn.className = "btn-opt";
                btn.innerHTML = `<b>${it.n}</b> ğŸ’°${it.p}<br><small>${it.d || ''}</small>`;
                btn.onclick = () => { if (gold >= it.p) { gold -= it.p; it.f(); updateUI(); if (b.type !== "è¨“ç·´æ‰€") openModal(b); } };
                c.appendChild(btn);
            });
        }
        function draw() {
            tick++; ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.globalAlpha = 1.0; ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < GH; y++) for (let x = 0; x < GW; x++) {
                ctx.fillStyle = (dungeon[y][x] === 1) ? "#1a252f" : "#050505";
                ctx.fillRect(x * TILE, y * TILE, TILE - 1, TILE - 1);
            }
            stairs.forEach(s => {
                let cx = s.x * TILE + 14, cy = s.y * TILE + 14;
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(tick * 0.05);
                ctx.strokeStyle = "#3498db"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
            });

            //ç¹ªè£½è§’è‰²
            ctx.font = "24px Arial"; ctx.textAlign = "center"; ctx.fillText("ğŸ§™â€â™‚ï¸", player.x * TILE + 14, player.y * TILE + 22);

            effects.forEach((eff) => {
                ctx.save(); ctx.globalAlpha = Math.max(0, eff.l / 15); ctx.fillStyle = eff.c;
            if (eff.type === 'text') {
                // å›ºå®šå­—é«”å¤§å°
                ctx.font = `bold 15px Arial`; 
                ctx.fillStyle = eff.c; 
                ctx.textAlign = "center";
                
                // æ ¹æ“š eff.l åˆ¤æ–·é€æ˜åº¦ (å‡è¨­æœ€å¤§ç”Ÿå‘½å€¼æ˜¯ 60 æˆ– 20)
                // æˆ‘å€‘åšå€‹ç›¸å®¹æ€§è™•ç†ï¼š
                let maxL = eff.l > 20 ? 60 : 20; 
                let alpha = eff.l > (maxL/3) ? 1.0 : eff.l / (maxL/3);
                ctx.globalAlpha = alpha;
            
                // é—œéµä¿®æ­£ï¼šè®“ lift æ ¹æ“šå…¶å¯¦éš›ç”Ÿå‘½é€±æœŸç§»å‹•
                // å¦‚æœ eff.l æ˜¯å¾ 60 é–‹å§‹æ‰£ï¼Œ(maxL - eff.l) å°±æ˜¯ã€Œå·²ç¶“éçš„æ™‚é–“ã€
                let lift = 5 + (maxL - eff.l) * 0.4; 
                
                ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
                ctx.lineWidth = 2;
                ctx.strokeText(eff.txt, eff.x * TILE + 14, eff.y * TILE - lift);
                ctx.fillText(eff.txt, eff.x * TILE + 14, eff.y * TILE - lift);
            }else if (eff.type === 'mine_exp') {
                    let prg = (15 - eff.l) / 15;
                    ctx.beginPath(); ctx.arc(eff.x * TILE + 14, eff.y * TILE + 14, prg * TILE * 2, 0, Math.PI * 2); ctx.fill();
                } else { ctx.fillRect(eff.x * TILE, eff.y * TILE, TILE, TILE); }
                ctx.restore(); eff.l--;
            });
            effects = effects.filter(eff => eff.l > 0);
            ctx.globalAlpha = 1.0; ctx.setLineDash([]); ctx.shadowBlur = 0;
            traps.forEach(t => {
                ctx.fillStyle = "#9b59b6"; ctx.beginPath(); ctx.arc(t.x * TILE + 14, t.y * TILE + 14, 6, 0, Math.PI * 2); ctx.fill();
            });
            buildings.forEach(b => { ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.fillText(b.icon, b.x * TILE + 14, b.y * TILE + 22); });
            enemies.forEach(en => {
                ctx.font = en.type === "boss" ? "40px Arial" : (en.type === "elite" ? "32px Arial" : "24px Arial");
                ctx.textAlign = "center"; ctx.fillText(en.emoji, en.x * TILE + 14, en.y * TILE + 22);
                ctx.fillStyle = "#e74c3c"; ctx.fillRect(en.x * TILE + 4, en.y * TILE, (TILE - 8) * (en.hp / en.maxHp), 3);
                if (en.freeze > 0) { ctx.strokeStyle = "#3498db"; ctx.lineWidth = 3; ctx.strokeRect(en.x * TILE + 1, en.y * TILE + 1, TILE - 2, TILE - 2); }
            });

        }
        function closeModal() { document.getElementById('game-modal').style.display = 'none'; }
        window.addEventListener('keydown', e => {
            if (document.getElementById('game-modal').style.display === 'block') return;
            let k = e.key.toUpperCase();
            if (k === 'W') movePlayer(0, -1); if (k === 'S') movePlayer(0, 1);
            if (k === 'A') movePlayer(-1, 0); if (k === 'D') movePlayer(1, 0);
            if (SPELL_DATA[k]) castSpell(k);
        });
        initLevel(); updateUI(); setInterval(draw, 50);
    </script>
</body>

</html>
